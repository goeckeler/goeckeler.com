+++
title   = "Developers Goodies"
date    = 2016-05-31
type    = "post"
draft   = true
+++

Every programmer dreams of greenfield projects. However, live is different. Especially if you are inclined to code in Java like myself. This language is around for a while, and a lot of code has been written in Java. So from time to time you are called in to extend code written by other developers.

Lately I was summoned to migrate an existing application to a new platform. The code has been matured for a long time, so to say, and many coders had made their impression. That includes premium hackers and brilliant software engineers. Unluckily most times the lower-priced developers won the contracts. Lucky me, as now I can present some code I came across so many times I stopped counting.

```java
public ArrayList<CrypticDO> fetchReadReceiptForNo(String pnr, boolean includingUnread)
  throws RemoteException, CrypticBackendException
{
  if (LOG.isTraceEnabled()) {
    LOG.trace("Begin: CrypticWebBackendImpl.fetchReadReceiptForNo");
  }
  if (true) {
    throw this.crypticBackendExceptionFactory
              .createNotImplementedException("fetchReadReceiptForNo not implemented");
  }
  if (LOG.isTraceEnabled()) {
    LOG.trace("End: CrypticWebBackendImpl.fetchReadReceiptForNo");
  }
  return null;
}
```

May-be I should mention we are talking about an application using the Spring framework. And the code is used by other systems and real users for a couple of years. I replaced a very cryptic shortcut in the sample code with the word _"cryptic"_.

## What can be improved in this code? ##

Actually, the simplest solution would be to delete it. The code exists for years and just produces an error, so we can reckon it is not called by anyone.

Just assume we cannot do so, may-be because the API needs to be backward compatible. Furthermore suppose that the code really contains business logic to be called.

Now, how to start?

## Use interfaces, not implementations! ##

Have a closer look at the method signature:

```java
public ArrayList<CrypticDO> fetchReadReceiptForNo(...)
```

Warum muss es unbedingt eine `ArrayList` sein? Warum muss der Aufrufer wissen, welche Implementierung wir intern verwenden? Und was heißt das für den Code, wenn wir die interne Implementierung austauschen, z.B. gegen eine `LinkedList`?

Wenn die Reihenfolge wichtig ist, dann sollte die Signatur so ausschauen:

```java
public List<KryptischesDO> holeLesebestaetigungenZuNr(...)
```

Wenn die Reihenfolge nicht wichtig ist, sollten wir Signatur so verändern, damit wir intern z.B. zwischen `Set` und `List` wechseln können:

```java
public Collection<KryptischesDO> holeLesebestaetigungenZuNr(...)</pre>
```

Wenn ich mir nicht sicher bin, ob die Reihenfolge wichtig ist oder nicht, oder wenn ich auf der Liste etwas tun will, dann sollte ich dafür gleich eine eigenes Transferobjekt verwenden:

```java
public KryptischeObjekte holeLesebestaetigungenZuNr(...)
```

## Warum verwende ich `LOG.isDebugEnabled()` ? ##

Der Code ist ein wunderbares Beispiel für Copy & Paste ohne Nachdenken. Was meint der Entwickler, wie der Entwickler des Logging-Frameworks wohl den Aufruf `trace` umgesetzt hat?

```java
if (LOG.isTraceEnabled()) {
  LOG.trace("Begin: KryptischesWebBackendImpl.holeLesebestaetigungenZuNr");
}
```

Egal, wie das Framework aussieht, der Code wird gewisse Ähnlichkeit mit dem folgenden stark vereinfachtem Fragment haben:

```java
public void trace(final String message) {
  if (isTraceEnabled()) {
    output.append(message);
  }
}
```

Wann verwende ich tatsächlich `isTraceEnabled()` bzw. `isDebugEnabled()` in meinem Code? Genau dann, wenn ich die Erzeugung der Fehlermeldung selber vermeiden möchte:

```java
if (LOG.isTraceEnabled()) {
  LOG.trace("Begin: " + StackUtils.getCallingClass() + "." + StackUtils.getCallingMethod());
}
```

Wenn ich hier kein `isTraceEnabled()` abfrage, dann wird der String zusammengesetzt, bevor im Code von `trace()` abgefragt wird, ob überhaupt eine Ausgabe erfolgen soll. Und damit würden auch die potentiell teuren Abfragen auf dem `StackTrace` erfolgen.

Wenn ich allerdings nur das Zusammensetzen der Nachricht aus verschiedenen Parametern vermeiden möchte, dann hilft der kleine Umweg über `String.format()` schnell weiter:

```java
  private static final String CLASS_NAME = "KryptischesWebBackendImpl";

  ...

  {
    String methodName = "holeLesebestaetigungenZuNr";
    LOG.trace(String.format("Begin: %1s.%2s", CLASS_NAME, methodName));
  }
```

## Lagere cross-cutting concerns einfach aus! ##

An dem Code ist natürlich besonders interessant, dass er sehr resistent gegen Refactoring ist. Klassennamen und Methodennamen werden als Zeichenketten in jeder Methode abgelegt. Was passiert wohl mit den Ausgaben, wenn sich der Name einer Methode ändert?

Im vorliegenden Beispiel gibt es rund 60 solcher Klassen mit durchschnittlich 10 Methoden.

Wie lange haben die Entwickler wohl daran gesessen, nur den Code zum Loggen hinzuzufügen? Jetzt hoffen wir einfach mal, dass die Klasse nicht nur erzeugt worden ist, um die Log-Ausgabe zu ermöglichen. Wobei der reale Code mich da eher zweifeln lässt. Wenn ich so oft fast den gleichen Code schreiben muss, ist es dann nicht an der Zeit, darüber nachzudenken, wie das auch einfacher geht?

In diesem Fall hätte das oberflächliche Lesen der Dokumentation zu Spring schon weiter geholfen. Selbst in älteren Versionen hätte folgende Konfiguration geholfen:

```xml
<bean id="customizableTraceInterceptor" class="org.springframework.aop.interceptor.CustomizableTraceInterceptor">
  <property name="enterMessage" value="Begin: $[targetClassShortName].$[methodName]"/>
  <property name="exitMessage" value="End: $[targetClassShortName].$[methodName]"/>
</bean>

<aop:config>
  <aop:advisor advice-ref="customizableTraceInterceptor"
               pointcut="execution(public * com.kryptisch.service.*(..))"/>
</aop:config>
```

Statt `CustomizableTraceInterceptor` lässt sich natürlich auch der `SimpleTraceInterceptor` verwenden. Ab Spring 2.5 lässt sich auch prima mit `@Aspect` eine eigene Implementierung dagegen setzen. Dieser könnte vereinfacht wie folgt aussehen:

```java
@Aspect
public class LogServiceCalls
{
  @Around( "execution(* com.xyz.service.*.*(..))" )
  public Object log(ProceedingJoinPoint join) throws Throwable {
    final Signature signature = join.getSignature();
    final String description = signature.getDeclaringTypeName() + "." + signature.getName();

    final Logger log = ...;

    log.trace(String.format("Begin: %1s, description));
    Object retVal = join.proceed();
    log.trace(String.format("End: %1s, description));

    return retVal;
  }
```

Was bleibt noch vom Code, wenn wir diese Vorschläge umsetzen?

```java
public List<KryptischesDO> holeLesebestaetigungenZuNr(String vsnr, boolean inklusiveUngelesene)
  throws RemoteException, KryptischesBackendException
{
  if (true) {
    throw this.kryptischesBackendExceptionFactory
              .createNotImplementedException("holeLesebestaetigungenZuNr not implemented");
  }
  return null;
}
```

## Was wahr ist, wird auch wahr bleiben. ##

Warum hat der Entwickler ursprünglich `if (true) { ... }` eingebaut? Was wahr ist, wird immer wahr bleiben. Ganz einfach: Ansonsten hätte sich der Compiler beschwert, dass der Code nach dem Schmeißen der Ausnahme nie erreicht wird. Der Entwickler hätte also den Code umschreiben müssen und hätte dabei den Platzhalter-Code löschen müssen:

```java
public List<KryptischesDO> holeLesebestaetigungenZuNr(String vsnr, boolean inklusiveUngelesene)
  throws RemoteException, KryptischesBackendException
{
  LOG.trace("Begin: KryptischesWebBackendImpl.holeLesebestaetigungenZuNr");

  throw this.kryptischesBackendExceptionFactory
            .createNotImplementedException("holeLesebestaetigungenZuNr not implemented");
}
```

Immerhin besser lesbarer als die ursprüngliche Version, und er hätte gleich den Nachteil seines Logging-Ansatzes gesehen: Was wird eigentlich ausgegeben, wenn die eigentliche Geschäftsmethode einen Fehler wirft? Genau, nichts.

Überlassen wir das Loggen also dem Aspekt und unternehmen noch den letzten Schritt und vereinfachen den Code weiter. Somit bleibt nur noch der Aufruf der eigentlichen Geschäftslogik über:

```java
public List<KryptischesDO> holeLesebestaetigungenZuNr(String vsnr, boolean inklusiveUngelesene)
  throws RemoteException, KryptischesBackendException
{
  throw this.kryptischesBackendExceptionFactory
            .createNotImplementedException("holeLesebestaetigungenZuNr not implemented");
}
```

Den obigen Aspekt müssten wir nur um ein paar Zeilen erweitern:

```java
@Aspect
public class LogServiceCalls
{
  ...

  @AfterThrowing( "execution(* com.xyz.service.*.*(..))" )
  public void failure(...) {
    // ...
  }
```

## What else? ##

How would you code this function if you are allowed to change the interface? How would you name the parameters? I personally encourage never to abbreviate anything. What on earth is a *pnr*? Is it a product number, a purchase order number, a personal note receipt? Modern IDEs feature code completion, everyone is allowed to use it, and suddenly the code is more readable.

Genug schwadroniert. Wer findet, ich übertreibe masslos? Wer sagt, das geht aber besser? Und wer darf auch solchen Code warten?